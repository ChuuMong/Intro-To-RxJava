# PART 1 - Getting started

## Rx?

> 사용자는 실시간 데이터를 기대합니다. 그들은 당장 그들의 트윗이 보이길 원하고 명령이 당장 확인되길 원하며, 정확한 가격이 필요합니다. 또한 그들의 온라인 게임은 반응적일 필요가 있습니다. 개발자는 파이어-앤-포겟(발사 후 망각) 메시지를 요구합니다. 당신은 결과를 기다리는것을 막지 않고 준비가 되었을 때 결과를 푸시하고 싶습니다. 여러 개의 결과값을 사용하여 작업 할 때 준비가 되면 각각의 결과를 받기 원합니다. 전체 집합이 처리 될 때까지 기다리지 않으려고합니다. 세상은 밀어 붙이기 시작했습니다. 사용자는 우리가 따라잡길 기다리고 있습니다. 개발자는 데이터를 푸시 할 수 있는 도구를 가지고 있습니다. 개발자는 데이터를 푸시하기 위해 반응하는 도구가 필요합니다.

Rx에 오신 것을 환영합니다. 이 책은 [Rx.NET](http://msdn.microsoft.com/en-us/devlabs/gg577609)의 www.introtorx.com을 기반으로 하며 오리지널 Microsoft 라이브러리의 Netflix 구현인 [RxJava](https://github.com/ReactiveX/RxJava)를 초보자를 위해 소개합니다. Rx는 함수형 프로그래머에게 익숙한 선언적 스타일로 문제를 해결 할 수 있는 강력한 도구입니다. Rx는 다음과 같은 몇 가지 이점이 있습니다.

* 통합
    * Rx의 질의는 함수형 프로그래밍에서 영감을 얻은 다른 라이브러리와 동일한 스타일로 수행됩니다.(예: Java 스트림). Rx에서는 이벤트 스트림에서 함수 스타일 변환을 사용 할 수 있습니다.
* 확장
    * RxJava는 커스텀 연산자를 사용하여 확장 할 수 있습니다. Java가 이것이 일어나는 것을 허용하지는 않지만 RxJava는 다른 언어로 Rx구현을 찾을 수 있는 모든 확장성을 제공합니다.
* 선언
    * 기능적 변환은 선언적 방식으로 읽혀집니다.
* 구성
    * Rx 연산자는 더 복잡한 연산을 생성하기 위해 결합 될 수 있습니다.
* 변형
    * Rx 연산자는 한 유형의 데이터를 다른 유형으로 변환하여 필요에 따라 스트림을 축소, 매핑 또는 확장 할 수 있습니다.


## 언제 Rx를 써야할까?

Rx는 일련의 이벤트를 작성하고 소비하는 데 적합합니다. www.introtorx.com에 따르면 Rx에 대한 몇 가지 사용 사례를 제시합니다.

### Should use Rx

* 마우스 이동, 버튼 클릭과 같은 UI 이벤트
* 속성 변경, Collection 업데이트, "주문 완료","등록 승인"등의 도메인 이벤트
* 파일 감시자, 시스템 및 WMI 이벤트와 같은 인프라 이벤트
* 메시지 버스의 브로드캐스트, WebSocket API & Nivana와 같은 대기 시간이 짧은 미들웨어의 푸시 이벤트와 같은 통합 이벤트
* StreamInsight 또는 StreamBase와 같은 CEP 엔진과의 통합

### Could use Rx
* '미래'의 결과 또는 동등한 패턴

이러한 패턴은 미지 잘 구현되어있으며 Rx를 도입하면 개발 프로세스가 추가되지 않는 다는 것을 알고 있습니다.

### Rx를 사용하지 않는 사례
* Rx 라이브러리를 통해 작업하기 위해서 iterable을 observable로 변환해야합니다.

##### 계속 읽기

| 이전 | 다음 |
| --- | --- |
|   | [Key types](/Part 1 - Getting Started/2. Key types.md) |

